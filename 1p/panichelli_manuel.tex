\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc} 
%\usepackage[spanish]{babel} 

% Para hipervinculos en las referencias
\usepackage{hyperref}

% Para enumerate con letras
\usepackage[shortlabels]{enumitem}

% Para dibujar grafos
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta}

% Figuras y subfiguras
\usepackage{caption}
\usepackage{subcaption} % subfiguras
\usepackage{float}      % [H] en figuras

% Simbolos matematicos
\usepackage{amsmath,amsfonts,amssymb,amsthm,epsfig,epstopdf,titling,url,array}

% \overbrace y \underbrace
\usepackage{mathtools}

% Algoritmos
% https://shantoroy.com/latex/how-to-write-algorithm-in-latex/
\usepackage{algorithm}
\usepackage[noend]{algpseudocode} % noend para que no tenga endfor y eso

\usepackage{fullpage}
\usepackage{fancyhdr}

% Teoremas, corolarios, etc.
% https://www.overleaf.com/learn/latex/theorems_and_proofs
\theoremstyle{definition} % Para que no salga en italicas
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}{Lema}

\pagestyle{fancyplain}
\fancyhf{}

\renewcommand{\headrulewidth}{0pt}

\rhead{Manuel Panichelli}
\chead{1er Parcial AED3: Parte Domiciliaria}
\lhead{L.U. 72/18}

% Distancia del header (\chead) al texto
\setlength{\headsep}{5pt}

\title{1er Parcial AED3: Parte Domiciliaria}
\author{Manuel Panichelli, 72/18}
\date{\today}

\begin{document}

\maketitle
\newpage

\chapter*{Preámbulo}

Teoremas / Ejercicios utilizados.

\section{Arboles}

\begin{theorem}[Definiciones equivalentes de árbol]\label{teo:tree-equiv}
    Dado $G = (V, X)$ un grafo, las siguientes son equivalentes:

    \begin{enumerate}
        \item G es un árbol, un grafo conexo sin circuitos simples.
        \item G es un grafo sin circuitos simples, y $e$ arista tq $e \notin X$,
        el grafo $G + e$ tiene exactamente un circuito simple el cual contiene a
        $e$.\label{teo:tree-equiv-circ}
        \item G es conexo, pero si se saca cualquier arista queda un grafo no
        conexo. Es decir, toda arista es puente.\label{teo:tree-equiv-puentes}
    \end{enumerate}
\end{theorem}

\begin{lemma}\label{lema:tree-g-e}
    Sea $G = (V, X)$ conexo y $e \in X$.

    \[ G - e \ \text{es conexo} \iff \text{e pertenece a un circuito simple de G} \]
\end{lemma}

\begin{theorem}\label{teo:tree-t-e-f}
    Sean $T = (V, X_T)$ un AG de $G = (V, X)$, $e \in X \setminus X_T$. Luego $T + e - f$ con $f$ una arista del único circuito de $G+e$ es AG de $G$.
\end{theorem}

\chapter*{Resolución}

\section*{Ejercicio 1}

\section*{Ejercicio 2}

\textit{Hilera con n recipientes con $r_1, \ldots, r_n \in \mathbb{N}$ unidades de agua, se quiere traspasar a dos baldes con capacidades $B_1, B_2 \in \mathbb{N}$. En cada paso se toma el primer recipiente de la hilera y se vuelva completamente en uno de los baldes. Se repite mientras algun balde tenga capacidad suficiente para albergar \textbf{toda} el agua del recipiente. El objetivo es maximizar la cantidad de recipientes que se vuelcan.}

\textcolor{red}{TODO: explicar el ejemplo dado, y explicar mejor el algoritmo y la func recursiva.}

\begin{enumerate}[a)]
    \item Formulo de forma recursiva una solución del problema con una función matemática $f(i, b)$ la cual tendrá la siguiente semántica: $f(i, b)$ es la máxima cantidad de recipientes que se pueden volcar suponiendo que ya se volcaron $r_1, ... r_{i-1}$ y que el balde con capacidad $B_1$ tiene $b$ de capacidad restante. Observo que esta información es suficiente para inferir la capacidad restante del balde $B_2$, dada por 
    
    \[ 
        b_2 = B_2 -
            \overbrace{
            \underbrace{\sum_{j=1}^{i-1} r_j}_{\substack{\text{total}\\\text{volcado}}} - 
            \underbrace{(B_1 - b)}_{\text{usado en} \ B_1}
            }^{\text{usado en} \ B_2}
    \]

    Veamos la función recursiva:

    \[ 
        f(i, b) =
            \begin{cases}
                0 & \text{si} \ (r_i > b \ \text{y}\  r_i > b_2) \ \text{o} \ i = n \\
                f(i+1,\ b) &\text{si}\ r_i > b\\
                f(i+1,\ b - r_i) &\text{si}\ r_i > b_2\\
                max\{f(i+1, b),\ f(i+1,\ b - r_i)\} &\text{si no}
            \end{cases}
    \]

    \item Es fácil ver que tiene la propiedad de \textit{superposición de subproblemas}, por ejemplo cuando más de un recipiente tiene la misma cantidad de agua. Sean $r_1 = r_2 = 5, r_3 = 10$ y $B_1 = B_2 = 20$.
    
    % https://texample.net/tikz/examples/tree/
    \begin{figure}[H]
        \centering
        \begin{tikzpicture}[
            every node/.style = {
                shape=rectangle, rounded corners,
                draw, align=center,
                top color=white
            }
        ]
        \tikzstyle{level 1}=[sibling distance=60mm] 
        \tikzstyle{level 2}=[sibling distance=30mm] 
        \tikzstyle{level 3}=[sibling distance=20mm] 

            \node{f(1, 20)}
                child { 
                    node{f(2, 15)}
                        child { node{f(3, 10)} }
                        child { node[color=red]{f(3, 15)} }
                }
                child { 
                    node{f(2, 20)}
                        child { node[color=red]{f(3, 15)} }
                        child { node{f(3, 20)} }
                };
        \end{tikzpicture}
        \caption{Ejemplo de superposoción de subproblemas. En rojo las llamadas que se superponen.}
    \end{figure}

    \item A continuación un algoritmo de programación dinámica \textit{top-down} que implementa la función recursiva de forma bastante directa, agregando memoización mediante una matriz $M$ de $n \times B_1$. Suponiendo que $B_1, B_2$, los $r_i$ y $M$ son globales,
    
    % http://tug.ctan.org/macros/latex/contrib/algorithmicx/algorithmicx.pdf
    \begin{algorithm}[H]
        \caption{Implementación con programación dinámica.}
        \begin{algorithmic}[1]
            \Function{Baldes}{$i,\ b$}
                \State $b_2\gets B_2 - \sum_{j=1}^{i-1} r_j - (B_1 - b)$ \Comment{$O(n)$}
                \If{$i = n$ o ($r_i > b$ y $r_i > b_2$)}
                    \State \textbf{return} 0
                \EndIf

                \If{$M[i][b] = -1$} \Comment{No está memoizado}
                    \If{r}
                        \State $M[i][b] \gets Baldes(i + 1, b)$
                    \ElsIf{a}
                        \State $M[i][b] \gets Baldes(i + 1, b - r_i)$
                    \Else
                        \State $M[i][b] \gets max\{Baldes(i+1, b),\ Baldes(i+1, b - r_i)\}$
                    \EndIf
                \EndIf

                \State \textbf{return} $M[i][b]$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}
    
    El problema se resuelve con el llamado $Baldes(0, B_1)$

    \item La complejidad temporal del algoritmo \textit{top-down} es igual a cualquier otro algoritmo de PD, \#subproblemas $\times$ costo de cada subproblema. En este caso, $O((n \times B_1) \times n) = O(n^2 \times B_1)$. Noto que esto podria mejorarse a $O(n \times B_1)$ si no se calculara $b_2$ en cada llamado, sino se fuera incrementando y se pasara por parametro.
        
\end{enumerate}

\section*{Ejercicio 3}

\section*{Ejercicio 4}

\textit{Un \textbf{puente} de un grafo es un eje del grafo tal que al removerlo
se obtiene un grafo con más c.cs. Sea $G = (V, X)$ un grafo conexo y $e \in X$.
Demostrar que e es un puente de G sii e pertenece a todo AG de G.}

\begin{proof}[Dem]
    Demostremos la ida y la vuelta.

    \begin{enumerate}
        \item[$\Rightarrow$)] Sea $e$ puente de G. qvq pertenece a todo AG de G.\\
        Va por el absurdo: supongo que no pertenece a ningún árbol generador de G, y sea $T = (V, X_T)$ uno cualquiera. Como $e \notin T$, por (\ref{teo:tree-equiv}.\ref{teo:tree-equiv-circ}), $T + e$ tiene exactamente un circuito simple $C$, el cual contiene a e. Sea $f \in C, f \in X_T$. Como $f$ pertenece al único circuito de $T + e$, por (\ref{teo:tree-t-e-f}) el árbol $T' = T + e - f$ es árbol generador de G, y $e \in T'$. Pero estabamos suponiendo que $e$ no pertenecía a ningún AG de G. Abs! Entonces pertenece a todos.

        \item[$\Leftarrow$)] Como $e$ pertenece a todo AG de G, y por
        (\ref{teo:tree-equiv}.\ref{teo:tree-equiv-puentes}) todas las aristas de un arbol son puente, en particular $e$ es puente de G.
    \end{enumerate}

\end{proof}

\section*{Ejercicio 5}

\textit{Cabinas de peaje inverso, en las que se le paga un monto al conductor que pase. Cada cabina de peaje $i \in \{1 \dotso C \}$ tiene un costo asociado $c_i$, el cual es negativo para las cabinas inversas, y el costo $c_{ij}$ del viaje de la cabina $i$ a la $j$, en caso de que se pueda de forma directa.}

\begin{enumerate}[a)]
\item Para modelar el problema, me gustaría representar a las cabinas como nodos, donde una cabina es adyacente a otra si se puede viajar de forma directa. Pero tenemos un problema, las aristas y los vértices tendrían peso, cuando los grafos que modelamos solo tienen peso en las aristas. Vamos a tener que usar una representación muy similar a la de la clase de Mirko. % \footnote{\url{https://campus.exactas.uba.ar/pluginfile.php/232068/mod_resource/content/1/CAMINOS%20MINIMOS.pdf}}.
Veamos un ejemplo

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{tikzpicture}[scale = 1,every node/.style={draw,circle,fill=white}]
            % La sintaxis es \node[opciones] (nombre del nodo) {dentro};    
            \node[label={1}](1) at (0,0) {$c_1$};
            \node[label={2},right= 40mm of 1] (2) {$c_2$};
        
            \draw[line width=0.5mm,-latex] (1) to node[midway,below,draw=none,fill=none]{$c_{12}$} (2); 
            \draw[line width=0.5mm,-latex] (2) to [bend right=60] node[midway,above,draw=none,fill=none]{$c_{21}$} (1);
        \end{tikzpicture}
        \caption{Digrafo original}
    \end{subfigure}
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{tikzpicture}[scale = 1,every node/.style={draw,circle,fill=white}]
            % La sintaxis es \node[opciones] (nombre del nodo) {dentro};    
            \node[label={$1_a$}](1a) at (0,0) {};
            \node[label={$1_b$}, right=10mm of 1a](1b) {};

            \node[label={$2_a$},right= 20mm of 1b] (2a) {};
            \node[label={$2_b$},right= 10mm of 2a] (2b) {};

            \draw[line width=0.5mm,-latex] (1a) to node[midway,below,draw=none,fill=none]{$c_{1}$} (1b);
            \draw[line width=0.5mm,-latex] (2a) to node[midway,below,draw=none,fill=none]{$c_{2}$} (2b);

            \draw[line width=0.5mm,-latex] (1b) to node[midway,below,draw=none,fill=none]{$c_{12}$} (2a); 
            \draw[line width=0.5mm,-latex] (2b) to [bend right=60] node[midway,above,draw=none,fill=none]{$c_{21}$} (1a);
        \end{tikzpicture}
        \caption{Digrafo adaptado}
    \end{subfigure}
    \caption{Ejemplo de representación de cabinas con digrafos}
    \label{5:adaptado}
\end{figure}

Separo cada nodo $i$ con peso $c_i$ en dos, $i_a$ e $i_b$, con un arco de peso $c_i$ de $i_a$ a $i_b$. Todos los arcos salen de $i_b$, y llegan a $i_a$. De esta forma, me aseguro que cualquier camino que pase por el nodo pague el costo del peaje. Luego, habrá un arco de $i_b$ a $j_a$ con peso $c_{ij}$ si es posible viajar de forma directa de la cabina $i$ a la $j$.

Matemáticamente, $G = (V, X)$ donde
\begin{align*}
    V = \ &\{ 1_a, 1_b, \ldots C_a, C_b\},\\
    X = \ &\{ (i_b, j_a, c_{ij}) \ |\ \text{se puede viajar de forma directa de i a j} \}\ \cup\\
      &\{ (i_a, i_b, c_i) \ | \ i \in \{1, \ldots, C\}\}.
\end{align*}

Con este modelo, se podrá obtener una ganancia recorriendo \textit{eternamente} las cabinas si el grafo tiene \textbf{ciclos negativos}, circuitos que luego de recorrerlos dan una ganancia.

\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{tikzpicture}[scale = 1,every node/.style={draw,circle,fill=white}]
            % La sintaxis es \node[opciones] (nombre del nodo) {dentro};    
            \node[label={$1_a$}](1a) at (0,0) {};
            \node[label={$1_b$}, right=10mm of 1a](1b) {};

            \node[label={$2_a$},right= 20mm of 1b] (2a) {};
            \node[label={$2_b$},right= 10mm of 2a] (2b) {};

            \draw[line width=0.5mm,-latex] (1a) to node[midway,below,draw=none,fill=none]{-10} (1b);
            \draw[line width=0.5mm,-latex] (2a) to node[midway,below,draw=none,fill=none]{-5} (2b);

            \draw[line width=0.5mm,-latex] (1b) to node[midway,below,draw=none,fill=none]{5} (2a); 
            \draw[line width=0.5mm,-latex] (2b) to [bend right=60] node[midway,above,draw=none,fill=none]{10} (1a);
        \end{tikzpicture}
        \caption{Cabinas sin ciclos negativos}
        \label{5/ej/sin}
    \end{subfigure}
    \begin{subfigure}[b]{0.4\textwidth}
        \centering
        \begin{tikzpicture}[scale = 1,every node/.style={draw,circle,fill=white}]
            % La sintaxis es \node[opciones] (nombre del nodo) {dentro};    
            \node[label={$1_a$}](1a) at (0,0) {};
            \node[label={$1_b$}, right=10mm of 1a](1b) {};

            \node[label={$2_a$},right= 20mm of 1b] (2a) {};
            \node[label={$2_b$},right= 10mm of 2a] (2b) {};

            \draw[line width=0.5mm,-latex] (1a) to node[midway,below,draw=none,fill=none]{-10} (1b);
            \draw[line width=0.5mm,-latex] (2a) to node[midway,below,draw=none,fill=none]{-5} (2b);

            \draw[line width=0.5mm,-latex] (1b) to node[midway,below,draw=none,fill=none]{5} (2a); 
            \draw[line width=0.5mm,-latex] (2b) to [bend right=60] node[midway,above,draw=none,fill=none]{\textbf{5}} (1a);
        \end{tikzpicture}
        \caption{Cabinas con ciclos negativos}
        \label{5/ej/con}
    \end{subfigure}
    \caption{Ejemplo de cabinas con y sin ciclos negativos}
    \label{5/ej}
\end{figure}

En la figura \ref{5/ej} se pueden ver dos ejemplos de cabinas y montos. En \ref{5/ej/sin} no hay ningún ciclo negativo, a pesar de que el camino $P: 1_a\ 1_b \ 2_a \ 2_b$ tiene costo -10, al volver a $1_a$ se vuelve 0, con lo cual recorrer infinitamente nunca daría ganancias. En cambio, en \ref{5/ej/con} se puede ver como con un pequeño ajuste, el ciclo $C: 1_a\ 1_b \ 2_a \ 2_b \ 1_a$ tiene costo -5, con lo cual se puede recorrer eternamente, generando ganancias.

\item Para resolver el problema del inciso anterior, basta con ver si hay ciclos negativos en algún camino de una cabina a la otra. Para ello, se puede usar el algoritmo de \textbf{Floyd}, pensado para resolver camino mínimo \textit{múltiples orígenes, múltiples destinos}, que puede ser adaptado para detectar ciclos negativos. Este tiene una complejidad temporal de $O(n^3)$ con $n$ la cantidad de vertices. Y en nuestro caso, $n = 2 \times|C|$, el doble de la cantidad de cabinas, ya que cada una se separa en dos nodos.

\end{enumerate}


\end{document}